{
  Diagnostics: null,
  Documents: [
    {
      FileName: AvroSourceGenerator\AvroSourceGenerator.AvroSourceGenerator\TestEnum.Avro.g.cs,
      Content:
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AvroSourceGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#pragma warning disable CS8618, CS8633, CS8714, CS8775
#nullable enable
namespace SchemaNamespace
{
    [global::System.CodeDom.Compiler.GeneratedCode("AvroSourceGenerator", "1.0.0.0")]
    public enum TestEnum
    {
        A,
        B,
        C,
    }
}
#nullable restore
#pragma warning restore CS8618, CS8633, CS8714, CS8775

    },
    {
      FileName: AvroSourceGenerator\AvroSourceGenerator.AvroSourceGenerator\NestedRecord.Avro.g.cs,
      Content:
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AvroSourceGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#pragma warning disable CS8618, CS8633, CS8714, CS8775
#nullable enable
namespace SchemaNamespace
{
    [global::System.CodeDom.Compiler.GeneratedCode("AvroSourceGenerator", "1.0.0.0")]
    public partial class NestedRecord : global::Avro.Specific.ISpecificRecord
    {    
        public required string NestedStringField { get; init; }
        public required int NestedIntField { get; init; }
     
        public global::Avro.Schema Schema { get => NestedRecord._SCHEMA; }
        public static readonly global::Avro.Schema _SCHEMA = global::Avro.Schema.Parse("""
        {
                    "type": "record",
                    "name": "NestedRecord",
                    "fields": [
                        { "name": "NestedStringField", "type": "string" },
                        { "name": "NestedIntField", "type": "int" }
                    ]
                }
        """);
    
        public object? Get(int fieldPos)
        {
            switch (fieldPos)
            {
                case 0: return this.NestedStringField;
                case 1: return this.NestedIntField;
                default: throw new global::Avro.AvroRuntimeException($"Bad index {fieldPos} in Get()");
            }
        }
        
        public void Put(int fieldPos, object? fieldValue)
        {
            switch (fieldPos)
            {
                case 0: NestedRecordReflection.Set_NestedStringField(this, (string)fieldValue!); break;
                case 1: NestedRecordReflection.Set_NestedIntField(this, (int)fieldValue!); break;
                default: throw new global::Avro.AvroRuntimeException($"Bad index {fieldPos} in Put()");
            }
        }
        
        private static class NestedRecordReflection
        {
            public static readonly global::System.Action<NestedRecord, string> Set_NestedStringField = CreateSetter<string>("NestedStringField");
            public static readonly global::System.Action<NestedRecord, int> Set_NestedIntField = CreateSetter<int>("NestedIntField");
        
            private static Action<NestedRecord, TProperty> CreateSetter<TProperty>(string propertyName)
            {
                var obj = global::System.Linq.Expressions.Expression.Parameter(typeof(NestedRecord), "obj");
                var value = global::System.Linq.Expressions.Expression.Parameter(typeof(TProperty), "value");
                var property = global::System.Linq.Expressions.Expression.Property(obj, typeof(NestedRecord).GetProperty(propertyName)!);
                var assign = global::System.Linq.Expressions.Expression.Assign(property, value);
                var lambda = global::System.Linq.Expressions.Expression.Lambda<Action<NestedRecord, TProperty>>(assign, obj, value);
                return lambda.Compile();
            }
        }
    }

}
#nullable restore
#pragma warning restore CS8618, CS8633, CS8714, CS8775

    },
    {
      FileName: AvroSourceGenerator\AvroSourceGenerator.AvroSourceGenerator\Record.Avro.g.cs,
      Content:
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AvroSourceGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#pragma warning disable CS8618, CS8633, CS8714, CS8775
#nullable enable
namespace SchemaNamespace
{
    [global::System.CodeDom.Compiler.GeneratedCode("AvroSourceGenerator", "1.0.0.0")]
    public partial class Record : global::Avro.Specific.ISpecificRecord
    {    
        public required string StringField { get; init; }
        public required int IntField { get; init; }
        public required long LongField { get; init; }
        public required float FloatField { get; init; }
        public required double DoubleField { get; init; }
        public required bool BooleanField { get; init; }
        public required byte[] BytesField { get; init; }
        public string? NullableStringField { get; init; }
        public int DefaultIntField { get; init; } = 42;
        public required SchemaNamespace.TestEnum EnumField { get; init; }
        public required global::System.Collections.Generic.IList<string> ArrayField { get; init; }
        public required global::System.Collections.Generic.IDictionary<string, int> MapField { get; init; }
        public required SchemaNamespace.NestedRecord NestedRecordField { get; init; }
        public required global::System.DateTime LogicalDateField { get; init; }
        public required global::System.DateTime LogicalTimestampField { get; init; }
     
        public global::Avro.Schema Schema { get => Record._SCHEMA; }
        public static readonly global::Avro.Schema _SCHEMA = global::Avro.Schema.Parse("""
        {
            "type": "record",
            "namespace": "SchemaNamespace",
            "name": "Record",
            "fields": [
                { "name": "StringField", "type": "string" },
                { "name": "IntField", "type": "int" },
                { "name": "LongField", "type": "long" },
                { "name": "FloatField", "type": "float" },
                { "name": "DoubleField", "type": "double" },
                { "name": "BooleanField", "type": "boolean" },
                { "name": "BytesField", "type": "bytes" },
                { "name": "NullableStringField", "type": ["null", "string"], "default": null },
                { "name": "DefaultIntField", "type": "int", "default": 42 },
                { "name": "EnumField", "type": { "type": "enum", "name": "TestEnum", "symbols": ["A", "B", "C"] } },
                { "name": "ArrayField", "type": { "type": "array", "items": "string" } },
                { "name": "MapField", "type": { "type": "map", "values": "int" } },
                { "name": "NestedRecordField", "type": {
                    "type": "record",
                    "name": "NestedRecord",
                    "fields": [
                        { "name": "NestedStringField", "type": "string" },
                        { "name": "NestedIntField", "type": "int" }
                    ]
                } },
                { "name": "LogicalDateField", "type": { "type": "int", "logicalType": "date" } },
                { "name": "LogicalTimestampField", "type": { "type": "long", "logicalType": "timestamp-millis" } }
            ]
        }
        """);
    
        public object? Get(int fieldPos)
        {
            switch (fieldPos)
            {
                case 0: return this.StringField;
                case 1: return this.IntField;
                case 2: return this.LongField;
                case 3: return this.FloatField;
                case 4: return this.DoubleField;
                case 5: return this.BooleanField;
                case 6: return this.BytesField;
                case 7: return this.NullableStringField;
                case 8: return this.DefaultIntField;
                case 9: return this.EnumField;
                case 10: return this.ArrayField;
                case 11: return this.MapField;
                case 12: return this.NestedRecordField;
                case 13: return this.LogicalDateField;
                case 14: return this.LogicalTimestampField;
                default: throw new global::Avro.AvroRuntimeException($"Bad index {fieldPos} in Get()");
            }
        }
        
        public void Put(int fieldPos, object? fieldValue)
        {
            switch (fieldPos)
            {
                case 0: RecordReflection.Set_StringField(this, (string)fieldValue!); break;
                case 1: RecordReflection.Set_IntField(this, (int)fieldValue!); break;
                case 2: RecordReflection.Set_LongField(this, (long)fieldValue!); break;
                case 3: RecordReflection.Set_FloatField(this, (float)fieldValue!); break;
                case 4: RecordReflection.Set_DoubleField(this, (double)fieldValue!); break;
                case 5: RecordReflection.Set_BooleanField(this, (bool)fieldValue!); break;
                case 6: RecordReflection.Set_BytesField(this, (byte[])fieldValue!); break;
                case 7: RecordReflection.Set_NullableStringField(this, (string?)fieldValue!); break;
                case 8: RecordReflection.Set_DefaultIntField(this, (int)fieldValue!); break;
                case 9: RecordReflection.Set_EnumField(this, (TestEnum)fieldValue!); break;
                case 10: RecordReflection.Set_ArrayField(this, (IList<string>)fieldValue!); break;
                case 11: RecordReflection.Set_MapField(this, (IDictionary<string, int>)fieldValue!); break;
                case 12: RecordReflection.Set_NestedRecordField(this, (NestedRecord)fieldValue!); break;
                case 13: RecordReflection.Set_LogicalDateField(this, (DateTime)fieldValue!); break;
                case 14: RecordReflection.Set_LogicalTimestampField(this, (DateTime)fieldValue!); break;
                default: throw new global::Avro.AvroRuntimeException($"Bad index {fieldPos} in Put()");
            }
        }
        
        private static class RecordReflection
        {
            public static readonly global::System.Action<Record, string> Set_StringField = CreateSetter<string>("StringField");
            public static readonly global::System.Action<Record, int> Set_IntField = CreateSetter<int>("IntField");
            public static readonly global::System.Action<Record, long> Set_LongField = CreateSetter<long>("LongField");
            public static readonly global::System.Action<Record, float> Set_FloatField = CreateSetter<float>("FloatField");
            public static readonly global::System.Action<Record, double> Set_DoubleField = CreateSetter<double>("DoubleField");
            public static readonly global::System.Action<Record, bool> Set_BooleanField = CreateSetter<bool>("BooleanField");
            public static readonly global::System.Action<Record, byte[]> Set_BytesField = CreateSetter<byte[]>("BytesField");
            public static readonly global::System.Action<Record, string?> Set_NullableStringField = CreateSetter<string?>("NullableStringField");
            public static readonly global::System.Action<Record, int> Set_DefaultIntField = CreateSetter<int>("DefaultIntField");
            public static readonly global::System.Action<Record, TestEnum> Set_EnumField = CreateSetter<TestEnum>("EnumField");
            public static readonly global::System.Action<Record, IList<string>> Set_ArrayField = CreateSetter<IList<string>>("ArrayField");
            public static readonly global::System.Action<Record, IDictionary<string, int>> Set_MapField = CreateSetter<IDictionary<string, int>>("MapField");
            public static readonly global::System.Action<Record, NestedRecord> Set_NestedRecordField = CreateSetter<NestedRecord>("NestedRecordField");
            public static readonly global::System.Action<Record, DateTime> Set_LogicalDateField = CreateSetter<DateTime>("LogicalDateField");
            public static readonly global::System.Action<Record, DateTime> Set_LogicalTimestampField = CreateSetter<DateTime>("LogicalTimestampField");
        
            private static Action<Record, TProperty> CreateSetter<TProperty>(string propertyName)
            {
                var obj = global::System.Linq.Expressions.Expression.Parameter(typeof(Record), "obj");
                var value = global::System.Linq.Expressions.Expression.Parameter(typeof(TProperty), "value");
                var property = global::System.Linq.Expressions.Expression.Property(obj, typeof(Record).GetProperty(propertyName)!);
                var assign = global::System.Linq.Expressions.Expression.Assign(property, value);
                var lambda = global::System.Linq.Expressions.Expression.Lambda<Action<Record, TProperty>>(assign, obj, value);
                return lambda.Compile();
            }
        }
    }

}
#nullable restore
#pragma warning restore CS8618, CS8633, CS8714, CS8775

    }
  ]
}